const _data = {
  firstPoint: null,
  rect: null,
};

export default {
  init() {
    _data.firstPoint = null;
    _data.rect = null;
  },

  drawObj(draw, options) {
    const { x, y, width, height } = fromData(draw.node, options.data);
    const r = draw.rect(width, height).move(x, y);
    const params = {
      color: options.color || 'black',
      dasharray: options.dasharray || '',
    };
    r.fill('none').stroke(params).data('egp', options);
  },

  mouseDown(event, draw, options) {
    const { type, name, color } = options;
    const { layerX: x, layerY: y } = event;
    const r = _data.rect;
    if (r) {
      r.stroke({color, dasharray: ''});
      r.data('egp', {
        id: new Date().getTime().toString(), type, name, color,
        data: toData(draw.node, {x: r.x(), y: r.y(), width: r.width(), height: r.height()}),
      });
      this.init();
      return r;
    } else {
      _data.rect = draw.rect(1, 1).move(x, x);
      _data.rect.fill('none').stroke({color, dasharray: '5,7'});
      _data.firstPoint = { x, y };
    };
  },

  mouseMove(event) {
    if (!_data.firstPoint || !_data.rect) return;
    const { layerX: x, layerY: y } = event;
    const r = pointsToRect(_data.firstPoint.x, _data.firstPoint.y, x, y);
    _data.rect.move(r.x, r.y).size(r.width, r.height);
  },

};

function toData(doc, rect) {
  const {clientWidth: w, clientHeight: h} = doc;
  return {
    x: rect.x / w,
    y: rect.y / h,
    width: rect.width / w,
    height: rect.height / h,
  };
};

function fromData(doc, rect) {
  const {clientWidth: w, clientHeight: h} = doc;
  return {
    x: rect.x * w,
    y: rect.y * h,
    width: rect.width * w,
    height: rect.height * h,
  };
};

function pointsToRect(x1, y1, x2, y2) {
  return {
    x: x1 < x2 ? x1 : x2,
    y: y1 < y2 ? y1 : y2,
    width: Math.abs(x1 - x2),
    height: Math.abs(y1 - y2),
  };
};
