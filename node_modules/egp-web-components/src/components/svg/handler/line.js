const _data = {
  line: null,
};

export default {
  init() {
    _data.line = null;
  },

  drawObj(draw, options) {
    const l = draw.line(fromData(draw.node, options.data));
    const params = {
      color: options.color || 'black',
      dasharray: options.dasharray || '',
    };
    l.stroke(params).data('egp', options);
    this._drawArrow(draw, l, options.color, options.options);
  },

  _drawArrow(draw, line, color, options) {
    if (options && options.arrow) {
      const arrow = draw.marker(32, 32, function (add) {
        add.path('M8,8 L32,16 L8,24 Z');
        add.style({ fill: color });
      });
      line.marker('end', arrow);
    };
  },

  mouseDown(event, draw, options) {
    const { layerX: x, layerY: y } = event;
    const l = _data.line;
    const { type, name, color } = options;
    if (l) {
      l.stroke({color, dasharray: ''});
      l.data('egp', {
        id: new Date().getTime().toString(), type, name, color,
        data: toData(draw.node, l.array().value),
      });
      this.init();
      return l;
    } else {
      _data.line = draw.line(x, y, x, y);
      _data.line.stroke({color, dasharray: '5,7'});
      
      this._drawArrow(draw, _data.line, color, options.options);
    };
  },

  mouseMove(event) {
    const { layerX: x, layerY: y } = event;
    const l = _data.line;
    if (!l) return;
    const points = l.array().value;
    if (points.length > 1) {
      points[points.length - 1] = [x, y];
      l.plot(points);
    };
  },

};

function toData(doc, line) {
  const {clientWidth: w, clientHeight: h} = doc;
  const result = [];
  line.forEach(point => result.push({x: point[0] / w, y: point[1] / h}));
  return result;
};

function fromData(doc, line) {
  const {clientWidth: w, clientHeight: h} = doc;
  const result = [];
  line.forEach(point => result.push([point.x * w, point.y * h]));
  return result;
};
